# ------------------ IMPORTS ------------------
import os
import numpy as np
import cv2
import tensorflow as tf
from tifffile import imread, imwrite
from tensorflow.keras.models import load_model
import matplotlib.pyplot as plt

# ------------------ CONFIG ------------------
IMG_HEIGHT, IMG_WIDTH = 256, 256
N_CLASSES = 3

input_dir = r"D:\Jyotsna_Kartik_BITS_2025\Chips_subset_9Feb_2024_for_test"
output_dir = r"D:\Jyotsna_Kartik_BITS_2025\predicted_masks_output"
model_path = "best_model.h5"

os.makedirs(output_dir, exist_ok=True)

# ------------------ CUSTOM LAYERS & METRICS ------------------
class PixelShuffle2D(tf.keras.layers.Layer):
    def __init__(self, upsampling_factor=2, **kwargs):
        super(PixelShuffle2D, self).__init__(**kwargs)
        self.upsampling_factor = upsampling_factor

    def call(self, inputs):
        return tf.nn.depth_to_space(inputs, self.upsampling_factor)

    def get_config(self):
        config = super().get_config()
        config.update({"upsampling_factor": self.upsampling_factor})
        return config

def multiclass_dice_coef(y_true, y_pred, smooth=1e-6):
    y_true = tf.cast(y_true, tf.float32)
    y_pred = tf.cast(y_pred, tf.float32)
    y_true = tf.reshape(y_true, (tf.shape(y_true)[0], -1))
    y_pred = tf.reshape(y_pred, (tf.shape(y_pred)[0], -1))
    intersection = tf.reduce_sum(y_true * y_pred, axis=1)
    denominator = tf.reduce_sum(y_true + y_pred, axis=1)
    dice = tf.reduce_mean((2. * intersection + smooth) / (denominator + smooth))
    return dice

def combined_loss(y_true, y_pred):
    y_pred = tf.keras.backend.clip(y_pred, 1e-7, 1 - 1e-7)
    cce = tf.keras.losses.categorical_crossentropy(y_true, y_pred)
    dice = 1 - multiclass_dice_coef(y_true, y_pred)
    return cce + dice

# ------------------ COLOR MAP FOR MASK ------------------
colormap = {
    0: [0, 0, 0],       # Background - Black
    1: [0, 255, 0],     # Pomegranate - Green
    2: [0, 0, 255],     # Date Palm - Blue
}

def decode_mask(pred_mask):
    color_mask = np.zeros((pred_mask.shape[0], pred_mask.shape[1], 3), dtype=np.uint8)
    for class_val, color in colormap.items():
        color_mask[pred_mask == class_val] = color
    return color_mask

# ------------------ LOAD MODEL ------------------
print("Loading model...")
model = load_model(model_path, compile=False, custom_objects={
    "PixelShuffle2D": PixelShuffle2D,
    "multiclass_dice_coef": multiclass_dice_coef,
    "combined_loss": combined_loss
})
print("Model loaded successfully.")

# ------------------ INFERENCE LOOP ------------------
image_filenames = sorted([f for f in os.listdir(input_dir) if f.endswith(".tif")])

for fname in image_filenames:
    img_path = os.path.join(input_dir, fname)
    image = imread(img_path)

    # Use Bands 2, 3, 4 if available
    if image.ndim == 3 and image.shape[2] >= 4:
        image = image[:, :, 1:4]
        print(image.shape)
    elif image.ndim == 2:
        image = np.stack([image] * 3, axis=-1)
    elif image.shape[2] < 3:
        raise ValueError(f"Image has insufficient channels: {image.shape}")

    # Normalize image
    image = image.astype(np.float32)
    image = image / (np.max(image) + 1e-6)

    input_tensor = np.expand_dims(image, axis=0)

    # Predict mask
    pred_probs = model.predict(input_tensor, verbose=0)[0]
    pred_mask = np.argmax(pred_probs, axis=-1).astype(np.uint8)

    # Save grayscale .tif mask
    save_path = os.path.join(output_dir, fname.replace(".tif", "_mask.tif"))
    imwrite(save_path, pred_mask)
    print(f"Saved: {save_path}")

    # Visualize input image and predicted mask
    plt.figure(figsize=(10, 4))

    plt.subplot(1, 2, 1)
    plt.imshow(np.clip(image * 255, 0, 255).astype(np.uint8))
    plt.title(f"Input Image (Bands 2-4): {fname}")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(pred_mask, cmap="jet", vmin=0, vmax=N_CLASSES - 1)
    plt.title("Predicted Mask")
    plt.axis("off")

    plt.tight_layout()
    plt.show()

